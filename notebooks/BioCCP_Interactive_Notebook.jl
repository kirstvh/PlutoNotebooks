### A Pluto.jl notebook ###
# v0.14.8

using Markdown
using InteractiveUtils

# This Pluto notebook uses @bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of @bind gives bound variables a default value (instead of an error).
macro bind(def, element)
    quote
        local el = $(esc(element))
        global $(esc(def)) = Core.applicable(Base.get, el) ? Base.get(el) : missing
        el
    end
end

# ‚ïî‚ïê‚ï° dc734eab-c244-4337-a0f3-469d77045eec
begin
	import Pkg
	Pkg.activate(mktempdir())
	using Pkg
	Pkg.add(["Plots", "PlutoUI"])
end


# ‚ïî‚ïê‚ï° e1a7f2da-a38b-4b3c-a238-076769e46408
begin	
using Plots, PlutoUI
function exp_ccdf(n, t; p_vec = ones(n), m = 1, r = 1, normalize = true)   
    @assert length(p_vec) == n
	    
    # Normalize probabilities
    if normalize
        p_vec = p_vec ./ sum(p_vec)    
    end   
    # Initialize probability P
    P_cdf = 1
    for i in 1:n
          Sm = 0
        for j in 1:m
            Sm += ((p_vec[i]*r*t)^(j-1))/factorial(j-1) #formulas see paper <Introduction
        end 
        P_cdf *= (1 - Sm*exp(-p_vec[i]*r*t))        
    end   
    P = 1 - P_cdf
    return P
end 
	
function approximate_moment(n, fun; p_vec = ones(n), q=1, m = 1, r = 1,
	        steps = 10000, normalize = true)
    @assert length(p_vec) == n
    a = 0; b = 0
    while fun(n, b; p_vec = p_vec, m = m, r=r, normalize=normalize) > 0.00001
        b += 5
    end
    Œ¥ = (b-a)/steps; t = a:Œ¥:b
    qth_moment = q .* sum(Œ¥ .* fun.(n, t; p_vec = p_vec, m = m, r=r, normalize = normalize) .* t.^[q-1]) #integration exp_ccdf, see paper References [1]
    return qth_moment           
end
	
function expectation_minsamplesize(n; p_vec = ones(n), m = 1, r = 1, normalize = true)
    @assert length(p_vec) == n
    E = approximate_moment(n, exp_ccdf; p_vec = p_vec, q = 1, m = m, r = r, normalize = normalize)
    return ceil(E)
end

function std_minsamplesize(n; p_vec = ones(n), m = 1, r = 1, normalize = true)
    @assert length(p_vec) == n
    M1 = approximate_moment(n, exp_ccdf; p_vec = p_vec, q=1, m = m, r = r,  normalize = normalize)
    M2 = approximate_moment(n, exp_ccdf; p_vec = p_vec, q=2, m = m, r = r, normalize = normalize)
    var = M2 - M1 - M1^2
    return ceil(sqrt(var))
end
	
function success_probability(n, t; p_vec = ones(n), m = 1, r = 1, normalize = true)   
    P_success = 1 - exp_ccdf(n, t; p_vec = p_vec, m = m, r = r, normalize = normalize) 
    return P_success
end
	
function expectation_fraction_collected(n, t; p_vec = ones(n), r = 1, normalize=true)
    if normalize
        p_vec = p_vec./sum(p_vec)
    end
    frac = sum( (1-(1-p_vec[i])^(t*r)) for i in 1:n )/n
    return frac
end
	
function prob_occurence_module(p, t, j)
	return (exp(-1*(p*t))*(p*t)^j)/factorial(j) 
end
	


md"‚ÄÇ "
end

# ‚ïî‚ïê‚ï° 4d246460-af05-11eb-382b-590e60ba61f5
md"## The Coupon Collector's Problem in Combinatorial Biotechnology

This notebook provides functions and visualizations to determine minimum sample sizes for biotechnological experiments, based on the mathematical framework of the Coupon Collector's Problem (implemented formulas based on [^1], [^2]).

"

# ‚ïî‚ïê‚ï° a8c81622-194a-443a-891b-bfbabffccff1
begin
md""" 
 
üëá **COMPLETE THE FIELDS BELOW** üëá

‚Ññ modules ‚àà design space: ‚ÄÇ‚ÄÇ ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ $(@bind n_string TextField(default = "100")) \
	
‚Ññ modules / design: ‚ÄÇ‚ÄÇ ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ ‚ÄÇ‚ÄÇ ‚ÄÇ‚ÄÇ‚ÄÇ $(@bind r NumberField(1:20))\
‚Ññ complete sets of modules to collect: ‚ÄÇ‚ÄÇ ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ $(@bind m NumberField(1:20))\
	
Abundances of modules during library generation: ‚ÄÇ‚ÄÇ ‚ÄÇ  $(@bind ps Select(["Equal", "Unequal"], default = "Equal"))"""
	
end

# ‚ïî‚ïê‚ï° 45507d48-d75d-41c9-a018-299e209f900e
begin
	n = parse(Int64, n_string);
	if ps == "Equal"
		distribution = "Equal"
	end
		if ps == "Unequal"	
	md""" 	‚ÄÇ ‚ÄÇ  ‚ÄÇ ‚ÄÇ ‚ÄÇ ‚ÄÇ ‚ÄÇ ‚ÄÇ ‚ÄÇ ‚ÄÇ ‚ÄÇ ‚ÄÇ ‚Ü≥  ‚ÄÇ  Specify distribution:  ‚ÄÇ   ‚ÄÇ   ‚ÄÇ   ‚ÄÇ     ‚Äâ‚Äâ‚Äâ  
	$(@bind distribution Select(["Bell curve", "Zipf law", "Custom vector"], default = " "))"""
		end	
end

# bell curve ipv normale distrbution, neem quantielen, niet samplen, vaste uitkomst

# ‚ïî‚ïê‚ï° b17f3b8a-61ee-4563-97cd-19ff049a8e1e
begin
	if distribution == "Bell curve"					
			md""" ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇp‚Çò‚Çê‚Çì/p‚Çò·µ¢‚Çô:‚Äâ $(@bind pmaxpmin_str TextField(default = "4")) 
‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ ‚ÄÇ‚ÄÇ‚Äâ‚Äâ‚Äâ """
			end
end

# ‚ïî‚ïê‚ï° e3b4c2d8-b78c-467e-a863-5eecb8ec58dc
begin
	if distribution == "Zipf law"
		md""" ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚Äâ‚ÄÇ‚ÄÇp‚Çò‚Çê‚Çì/p‚Çò·µ¢‚Çô:‚ÄÇ‚ÄÇ $(@bind pmaxpmin_string TextField(default = "4")) 
‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚Äâ‚Äâ‚Äâ‚ÄÇ‚Äâ‚Äâ‚ÄÇ‚ÄÇ‚Äâ‚Äâ‚ÄÇ """
			end

end

# ‚ïî‚ïê‚ï° 2639e3fb-ccbb-44de-bd15-1c5dbf6c1539
begin
	if distribution == "Custom vector"
				md"""‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ 	‚Äâ‚ÄÇ ‚ÄÇ ‚ÄÇ ‚Ü≥‚ÄÇ‚ÄÇEnter/load your custom abundances by changing the cell below üëá"""			
		end
end

# ‚ïî‚ïê‚ï° 44d4dfee-3073-49aa-867c-3abea10e6e37
begin
	# To load your custom probability vector from an excell sheet,
	# see for example XLSX package
	# Below, an example of a custom abundance vector is defined using rand
	if distribution == "Custom vector"
		abundances = rand(200:1:400, n)
	end
end

# ‚ïî‚ïê‚ï° f6ebf9fb-0a29-4cb4-a544-6c6e32bedcc4
md"""	
 
üéØ **REPORT**  üéØ

**üíª Module probabilities**‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ $(@bind show_modprobs Select(["üîª SHOW ", "üî∫ HIDE "], default="üî∫ HIDE ") ) ‚ÄÇ\
*How the abundances of the modules are distributed during combinatorial library generation.*
"""

# ‚ïî‚ïê‚ï° 081671f5-8103-4bfc-b84f-302df041d590
p_vec

# ‚ïî‚ïê‚ï° 87c3f5cd-79bf-4ad8-b7f8-3e98ec548a9f
begin
	if show_modprobs == "üîª SHOW "  && distribution == "Bell curve"
		histogram(p_vec, normalize=:probability,  bar_edges=false,  size = (650, 340), orientation=:v, bins=[(Œº -  3*œÉ)/sum(p_vec_unnorm), (Œº - 2*œÉ)/sum(p_vec_unnorm), (Œº-œÉ)/sum(p_vec_unnorm), (Œº + œÉ)/sum(p_vec_unnorm), (Œº + 2*œÉ)/sum(p_vec_unnorm), (Œº +  3*œÉ)/sum(p_vec_unnorm)])
		# if distribution == "Normally distributed"
		# 	plot!(x->pdf(Normal(Œº, œÉ), x), xlim=xlims())
		# 	xlabel!("Abundance"); ylabel!("probability"); title!("Distribution of module abundances")
		# end
		xlabel!("Probability"); ylabel!("Relative frequency"); title!("Distribution of module probabilities")
	end	
end

# ‚ïî‚ïê‚ï° 2313198e-3ac9-407b-b0d6-b79e02cefe35
begin
	if show_modprobs == "üîª SHOW "  && distribution == "Bell curve"
md"""For $n_string modules of which the probabilities form a bell curve with ratio p‚Çò‚Çê‚Çì/p‚Çò·µ¢‚Çô = $pmaxpmin_str , we follow the percentiles of a normal distribution to generate the probability vector.

We consider Œº to be the mean module probability and œÉ to be the standard deviation of the module probabilities.
		
According to the percentiles
- 68% of the module probabilities lies in the interval [Œº - œÉ, Œº + œÉ], 
- 95% of falls into the range [Œº - 2œÉ, Œº + 2œÉ] and 
- 99.7% lies in [Œº - 3œÉ, Œº +3œÉ]. 
		
We use the ratio p‚Çò‚Çê‚Çì/p‚Çò·µ¢‚Çô to fix the width of the interval [Œº - 3œÉ, Œº +3œÉ]. (We assume that p‚Çò‚Çê‚Çì = Œº +3œÉ and p‚Çò·µ¢‚Çô = Œº - 3œÉ and calculate Œº and œÉ from this assumption). In addition, we make sure the sum of the probability vector sums up to 1.
		
As a result, we get:
-  $(n_perc_1+n_perc_rest) modules with a probability of $(¬µ/sum(p_vec_unnorm))
-  $(n_perc_2)  modules with a probability of $((Œº+1.5*œÉ)/sum(p_vec_unnorm))
-  $(n_perc_2)  modules with a probability of $((Œº-1.5*œÉ)/sum(p_vec_unnorm))
-  $(n_perc_3)  modules with a probability of $((Œº+2.5*œÉ)/sum(p_vec_unnorm))
-  $(n_perc_3)  modules with a probability of $((Œº-2.5*œÉ)/sum(p_vec_unnorm))"""
	end	
end

# ‚ïî‚ïê‚ï° f098570d-799b-47e2-b692-476a4d95825b
if show_modprobs == "üîª SHOW " 
md"Each biological design in the design space is built by choosing $r module(s) out of a set of $n_string modules according to the module probabilities visualized above."
end

# ‚ïî‚ïê‚ï° caf67b2f-cc2f-4d0d-b619-6e1969fabc1a
md""" **üíª Minimum sample size required**‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ $(@bind show_E Select(["üîª SHOW ", "üî∫ HIDE "], default="üî∫ SHOW "))‚ÄÇ
\
*The number of designs required to observe each module at least $m times in the sampled set of designs.* """  

# ‚ïî‚ïê‚ï° 6f14a72c-51d3-4759-bb8b-10db1dc260f0
begin
	if show_E == "üîª SHOW "   
		E = Int(expectation_minsamplesize(n; p_vec = p_vec, m=m, r = r))
		sd = Int(std_minsamplesize(n; p_vec = p_vec, m=m, r = r))
		
			md""" 
‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ`Expected minimum sample size‚ÄÇ‚ÄÇ E[T‚Çö]` ‚ÄÇ‚ÄÇ‚ÄÇ = **$E designs**\
		
‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ`Standard deviation ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇsd[T‚Çö]` ‚ÄÇ‚ÄÇ‚Äâ‚Äâ‚Äâ= **$sd designs**  	"""
	end
	# begin
		
	# 	#E_vec = []
	# 	#sd_vec = []
			 
	# 	#if ps == "Unequal" && probs_unequal_norm
	# 			#iter = 10
	# 			#for i in 1:iter
	# 				#p_vec_i = rand(Normal(Œº,  œÉ), n)
	# 				#p_vec_i = p_vec_i ./ sum(p_vec_i)
	# 				#E_i = expectation_minsamplesize(n; p_vec = p_vec_i, m=m, q = q)
	# 				#sd_i = std_minsamplesize(n; p_vec = p_vec_i, m=m, q=q)
	# 				#push!(E_vec, E_i)
	# 				#push!(sd_vec, sd_i)
	# 			#end
	# 			#E = Int(ceil(mean(E_vec)))
	# 			#sd = Int(ceil(mean(sd_vec)))
	# 			#E_CI_lhs = Int(ceil( E - quantile(Normal(), 1-0.05/2)*sd/sqrt(iter)))
	# 			#E_CI_rhs = Int(ceil(E + quantile(Normal(), 1-0.05/2)*sd/sqrt(iter)))
	# 			#sd_CI_lhs = Int(ceil( sd - quantile(Normal(), 1-0.05/2)*sd/sqrt(iter)))
	# 			#sd_CI_rhs = Int(ceil(sd + quantile(Normal(), 1-0.05/2)*sd/sqrt(iter)))
				
			
	# 		#md""" 
	# 		#``` 
	# 		#Expected minimum sample size E[Tp]
	# 		#```		 	
	# 		#= **$E designs**    -------- 95% CI :  [$E_CI_lhs, $E_CI_rhs]
		
	# 		#``` 
	# 		#Standard deviation sd[Tp]  
	# 		#```	
		
	# 		#= **$sd designs**   -------- 95% CI :  [$sd_CI_lhs, $sd_CI_rhs]
		
	# 		#---------------
	# 		#"""
		
	# 		#else
	
	# #	E = expectation_minsamplesize(n; p_vec = p_vec, m=m, q = q)
	# #	sd = std_minsamplesize(n; p_vec = p_vec, m=m, q=q)
			
			
	# #		md""" 
	# #		``` 
	# #		Expected minimum sample size E[Tp]
	# #		```		 	
	# #		= **$E designs**    
		
	# #		``` 
	# #		Standard deviation sd[Tp]  
	# #		```	
		
	# #		= **$sd designs**   
		
	# #		---------------
	# #		"""
				 
	# 		#end
			
			
		 
	# #end
end

# ‚ïî‚ïê‚ï° 22fe8006-0e81-4e0a-a460-28610a55cd97
md""" **üíª Success probability**‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ $(@bind show_success Select(["üîª SHOW ", "üî∫ HIDE "], default="üî∫ HIDE ") )\

 + *The probability that all modules are observed for a given sample size.* """

# ‚ïî‚ïê‚ï° db4371e4-7f86-4db3-b076-12f6cd220b89
begin
	if show_success == "üîª SHOW " 
		md""" ‚ÄÇ‚ÄÇ‚ÄÇüëâ Enter your sample size of interest: $(@bind sample_size_1_string TextField(default="500"))"""‚ÄÇ
		
	end
	#genereer tabel + download knop
end

# ‚ïî‚ïê‚ï° 317995ed-bdf4-4f78-bd66-a39ffd1dc452
begin
	if show_success == "üîª SHOW " 
	sample_size_1 = parse(Int64, sample_size_1_string);
	
	p_success = success_probability(n, sample_size_1; p_vec = p_vec, m = m, r = r)
	
	md""" 
‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚Ü≥ `Succes probability F(T‚Çö)` ‚ÄÇ= **$p_success**\
	"""
	end
end

# ‚ïî‚ïê‚ï° ca5a4cef-df67-4a5e-8a86-75a9fe8c6f37
if show_success == "üîª SHOW " 
	md" + *A curve describing the success probability in function of sample size.*"
end

# ‚ïî‚ïê‚ï° 24f7aae7-d37a-4db5-ace0-c910b178da88
begin
if show_success == "üîª SHOW " 
	
sample_size_initial = 5
	while (1 - success_probability(n, sample_size_initial; p_vec = p_vec, r = r, m = m)) > 0.0005
		global sample_size_initial += 100
	end
		
	sample_sizes = 0:10:sample_size_initial
	successes = success_probability.(n, sample_sizes; p_vec = p_vec, r = r, m = m)
plot(sample_sizes, successes, title = "Success probability in function of sample", xlabel = "sample size s", ylabel= "P(s ‚â§ S‚Çò·µ¢‚Çô)", label = "", legend=:bottomright, size=(600,300), seriestype=:scatter )
		end
	 
end

# ‚ïî‚ïê‚ï° 37f951ee-885c-4bbe-a05f-7c5e48ff4b6b
begin
	#following one-sided version of Chebyshev's inequality.
	
	function chebyshev(X, Œº, œÉ)
    X_Œº = X - Œº
    k = abs(X_Œº)/œÉ
#     if k <= 1 
#         print(k)
#     end
    upperbound_prob  = 1/(k^2)
    
	end
	 
	function chebyshev_onesided_larger(X, Œº, œÉ)
		X_Œº = X - Œº
		return œÉ^2 / (œÉ^2 + X_Œº^2)
	end
	function chebyshev_onesided_smaller(X, Œº, œÉ)
		X_Œº = Œº - X
		return œÉ^2 / (œÉ^2 + X_Œº^2)
	end
if show_success == "üîª SHOW "
if sample_size_1 < E
	compare = "smaller"
		if sample_size_1 <= n/r
			print_sentence = "P(required sample size ‚â§ $sample_size_1) = 0.
     ‚ÄÇ ‚ÄÇ ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ    ‚ÄÇ ‚ÄÇ ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ    ‚ÄÇ ‚ÄÇ ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ    ‚ÄÇ ‚ÄÇ ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ    ‚ÄÇ ‚ÄÇ ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ    ‚ÄÇ ‚ÄÇ ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ    ‚ÄÇ ‚ÄÇ ‚ÄÇüö® Enter a sample size that is larger than (‚Ññ modules ‚àà design space)/(‚Ññ modules/design)  to obtain an upperbound probability > 0 üö®"
		else
	prob_chebyshev = chebyshev_onesided_smaller(sample_size_1, E, sd)
	print_sentence = "P(required sample size ‚â§ $sample_size_1)‚ÄÇ‚â§ $prob_chebyshev. "
		end
		
elseif sample_size_1 > E
	compare = "greater"
	prob_chebyshev = chebyshev_onesided_larger(sample_size_1, E, sd)
	print_sentence = "P(required sample size ‚â• $sample_size_1)‚ÄÇ‚â§ $prob_chebyshev. "	
		
	elseif sample_size_1==E
		print_sentence = "P(required sample size ‚â§ $sample_size_1 OR required sample size ‚â• $sample_size_1)‚ÄÇ‚â§ 1."
		
end

	md"""+  *Upperbound probability according to Chebychev's inequality.*:
	 ‚ÄÇ ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ    ‚ÄÇ $print_sentence"""
	end
end

# ‚ïî‚ïê‚ï° dc696281-7a5b-4568-a4c2-8dde90af43f0
md""" **üíª Expected saturation**‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚Äâ‚Äâ‚Äâ‚ÄÇ $(@bind show_satur Select(["üîª SHOW ", "üî∫ HIDE "], default="üî∫ HIDE "))\
*The expected fraction of total number of modules observed after collecting a giving number of designs.*"""

# ‚ïî‚ïê‚ï° eb92ff7c-0140-468c-8b32-f15d1cf15913
if show_satur == "üîª SHOW " 
		md"""
 ‚ÄÇ‚ÄÇüëâ Enter your sample size of interest: $(@bind sample_size_2_string TextField(default="50"))‚ÄÇ"""‚ÄÇ
end

# ‚ïî‚ïê‚ï° f0eaf96b-0bc0-4194-9a36-886cb1d66e00
begin
	if show_satur == "üîª SHOW " 
	sample_size_2 = parse(Int64, sample_size_2_string)
	E_fraction = expectation_fraction_collected(n, sample_size_2; p_vec = p_vec, r = r)
	
	md""" 	‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚Ü≥ `Expected fraction observed:`	= **$E_fraction**
	"""	
	end
end

# ‚ïî‚ïê‚ï° 0099145a-5460-4549-9513-054bc1b04eea
if  show_satur == "üîª SHOW " 
md""" *A curve describing the expected fraction of modules observed in function of sample size.* """
	end

# ‚ïî‚ïê‚ï° 7968de5e-5ae8-4ab4-b089-c3d33475af2f
begin
	if show_satur == "üîª SHOW " 
global sample_size_initial_frac = 5
		while (1 - expectation_fraction_collected(n, sample_size_initial_frac; p_vec = p_vec, r = r)) > 0.0005
		global	 sample_size_initial_frac += 100
		end
	
	sample_sizes_frac = 0:5: sample_size_initial_frac
	
	fracs = expectation_fraction_collected.(n, sample_sizes_frac; p_vec = p_vec, r = r)
	
	plot(sample_sizes_frac, fracs, title = "Expected fraction of modules observed", 
	    xlabel = "sample size", seriestype=:scatter, 
	    ylabel= "E[fraction observed]", label = "", size=(700,300))
end
end

# ‚ïî‚ïê‚ï° f92a6b6e-a556-45cb-a1ae-9f5fe791ffd2
md""" **üíª Occurence of a specific module**‚ÄÇ‚ÄÇ‚ÄÇ‚Äâ‚Äâ‚Äâ‚ÄÇ $(@bind show_occ Select(["üîª SHOW ", "üî∫ HIDE "], default="üî∫ HIDE "))\
*How many times one can expect to have collected a specific module in a sample of a given size.*"""

# ‚ïî‚ïê‚ï° ec2a065f-0dc7-44d4-a18b-6c6a228b3ffc
if show_occ == "üîª SHOW " && distribution != "Zipf law"
	md""" ‚ÄÇ‚ÄÇ‚ÄÇüëâ Enter the probability of the module of interest: $(@bind p_string TextField(default="0.005"))\
	 ‚ÄÇ‚ÄÇ‚ÄÇüëâ Enter the sample size of interest: ‚ÄÇ‚ÄÇ‚ÄÇ ‚ÄÇ‚ÄÇ‚ÄÇ ‚ÄÇ‚ÄÇ‚ÄÇ ‚Äâ‚Äâ $(@bind sample_size_3_string TextField(default="500"))
	"""‚ÄÇ	
	
end

# ipv probabiliteit --> rank i: sorteer modules

# ‚ïî‚ïê‚ï° 0e39a993-bb2f-4897-bfe2-5128ec62bef9
if show_occ == "üîª SHOW " && distribution == "Zipf law"
	md""" ‚ÄÇ‚ÄÇ‚ÄÇüëâ Enter the rank of the module of interest:‚ÄÇ‚ÄÇ ‚Äâ ‚ÄÇ‚ÄÇ $(@bind rank_string TextField(default="5"))\
	 ‚ÄÇ‚ÄÇ‚ÄÇüëâ Enter the sample size of interest: ‚ÄÇ‚ÄÇ‚ÄÇ ‚ÄÇ‚ÄÇ‚ÄÇ ‚ÄÇ‚ÄÇ‚ÄÇ ‚Äâ‚Äâ $(@bind sample_size_4_string TextField(default="500"))
	"""‚ÄÇ	
	
end

# ipv probabiliteit --> rank i: sorteer modules

# ‚ïî‚ïê‚ï° 6acb0a97-6469-499f-a5cf-6335d6aa909a
begin

	
if show_occ == "üîª SHOW " 
	if distribution != "Zipf law"
	p = parse(Float64, p_string)
	sample_size_3 = parse(Int64, sample_size_3_string)
 	# module_ = 1
# 	p = p_vec[module_]
# 	p = maximum(p_vec) 
	ed = Int(floor(sample_size_3*p))
	j = 0:1:8
			
	x  = prob_occurence_module.(p, sample_size_3, j)
	 plot(j,x, seriestype=[:line, :scatter], xlabel="‚Ññ occurences in sample", ylabel="probability p", title="Chance on ‚Ññ of occurences for specific module")
	
		else
		rank = parse(Int64, rank_string)
		p = p_vec[rank]
	sample_size_4 = parse(Int64, sample_size_4_string)
 	# module_ = 1
# 	p = p_vec[module_]
# 	p = maximum(p_vec) 
			ed = Int(floor(sample_size_4*p))
	j = 0:1:ed*2
			
	x  = prob_occurence_module.(p, sample_size_4, j)
	 plot(j,x, seriestype=[:line, :scatter], xlabel="‚Ññ occurences in sample", ylabel="probability p", title="Chance on ‚Ññ of occurences for specific module", size=((550,300)))	
			
		end
	end
end

# ‚ïî‚ïê‚ï° 595423df-728b-43b1-ade4-176785c54be3
begin
	if show_occ == "üîª SHOW " 

	
	md""" 	‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚Ü≥ `Expected times observed:`	‚âà **$ed**
		"""
	end
end

# ‚ïî‚ïê‚ï° fbffaab6-3154-49df-a226-d5810d0b7c38
md"""## References"""

# ‚ïî‚ïê‚ï° 1f48143a-2152-4bb9-a765-a25e70c281a3
md"""[^1]:  Doumas, A. V., & Papanicolaou, V. G. (2016). *The coupon collector‚Äôs problem revisited: generalizing the double Dixie cup problem of Newman and Shepp.* ESAIM: Probability and Statistics, 20, 367-399.

[^2]: Boneh, A., & Hofri, M. (1997). *The coupon-collector problem revisited‚Äîa survey of engineering problems and computational methods.* Stochastic Models, 13(1), 39-66.



"""


# ‚ïî‚ïê‚ï° b0291e05-776e-49ce-919f-4ad7de4070af
begin

	if ps == "Equal"
	 	
		p_vec = ones(n)./sum(ones(n));
		
	elseif ps == "Unequal"
		if distribution == "Bell curve"
			ratio = parse(Float64, pmaxpmin_str)
			ab1 = 1
			ab2 = ratio*ab1
			Œº = (ab1+ab2)/2
			œÉ = (ab2-ab1)/6
			
			#create fixed distribution of abundances according to percentiles of bell curve
			n_perc_1 = Int(floor(n*0.34)); 
			n_perc_2 = Int(floor(n*0.135));
			n_perc_3 = Int(floor(n*0.0215));
			#n_perc_4 = Int(floor(n*0.0013));
			n_perc_rest = n - 2*n_perc_1 - 2*n_perc_2 - 2*n_perc_3 ;
			p_vec_unnorm = vcat(fill(Œº,2*n_perc_1+n_perc_rest), fill(Œº+1.5*œÉ, n_perc_2), fill(Œº-1.5*œÉ, n_perc_2), fill(Œº+3*œÉ, n_perc_3), fill(Œº-3*œÉ, n_perc_3) )
		
			# normalize sum to 1
			p_vec = sort(p_vec_unnorm ./ sum(p_vec_unnorm))
		end
		
		if distribution == "Custom vector"
			p_vec_unnorm = abundances
			p_vec = abundances ./ sum(abundances)
		end
		
		if distribution == "Zipf law"
			ratio = parse(Float64, pmaxpmin_string)
			Œ± = exp(log(ratio)/(n-1))
			p_vec = collect(Œ±.^-(1:n))
			p_vec = p_vec ./ sum(p_vec)
		end
	end
	
	if show_modprobs == "üîª SHOW "   
	
	scatter(p_vec, title = "Probability mass function", ylabel = "module probability p‚±º", xlabel = "module j", label="", size = (700, 400))
	ylims!((0,maximum(p_vec) + maximum(p_vec)-minimum(p_vec) ))

	end	
end

# ‚ïî‚ïê‚ï° d4a9da7a-f455-426b-aecd-227c25e1d4e8
begin

	if ps == "Equal"
	 	
		p_vec = ones(n)./sum(ones(n));
		
	elseif ps == "Unequal"
		if distribution == "Bell curve"
			ratio = parse(Float64, pmaxpmin_str)
			Œº = ratio/2
			œÉ = ratio/6
			
			#create fixed distribution of abundances according to percentiles of bell curve
			n_perc_1 = Int(floor(n*0.34)); 
			n_perc_2 = Int(floor(n*0.135));
			n_perc_3 = Int(floor(n*0.0215));
			#n_perc_4 = Int(floor(n*0.0013));
			n_perc_rest = n - 2*n_perc_1 - 2*n_perc_2 - 2*n_perc_3 ;
			p_vec_unnorm = vcat(fill(Œº,2*n_perc_1+n_perc_rest), fill(Œº+1.5*œÉ, n_perc_2), fill(Œº-1.5*œÉ, n_perc_2), fill(Œº+2.5*œÉ, n_perc_3), fill(Œº-2.5*œÉ, n_perc_3) )
		
			# normalize sum to 1
			p_vec = sort(p_vec_unnorm ./ sum(p_vec_unnorm))
		end
		
		if distribution == "Custom vector"
			p_vec_unnorm = abundances
			p_vec = abundances ./ sum(abundances)
		end
		
		if distribution == "Zipf law"
			ratio = parse(Float64, pmaxpmin_string)
			Œ± = exp(log(ratio)/(n-1))
			p_vec = collect(Œ±.^-(1:n))
			p_vec = p_vec ./ sum(p_vec)
		end
	end
	
	if show_modprobs == "üîª SHOW "   
	
	scatter(p_vec, title = "Probability mass function", ylabel = "module probability p‚±º", xlabel = "module j", label="", size = (700, 400))
	ylims!((0,maximum(p_vec) + maximum(p_vec)-minimum(p_vec) ))

	end	
end

# ‚ïî‚ïê‚ï° Cell order:
# ‚ïü‚îÄ4d246460-af05-11eb-382b-590e60ba61f5
# ‚ïü‚îÄdc734eab-c244-4337-a0f3-469d77045eec
# ‚ïü‚îÄe1a7f2da-a38b-4b3c-a238-076769e46408
# ‚ïü‚îÄa8c81622-194a-443a-891b-bfbabffccff1
# ‚ïü‚îÄ45507d48-d75d-41c9-a018-299e209f900e
# ‚ïü‚îÄb17f3b8a-61ee-4563-97cd-19ff049a8e1e
# ‚ïü‚îÄe3b4c2d8-b78c-467e-a863-5eecb8ec58dc
# ‚ïü‚îÄ2639e3fb-ccbb-44de-bd15-1c5dbf6c1539
# ‚ïü‚îÄ44d4dfee-3073-49aa-867c-3abea10e6e37
# ‚ïü‚îÄf6ebf9fb-0a29-4cb4-a544-6c6e32bedcc4
# ‚ï†‚ïê081671f5-8103-4bfc-b84f-302df041d590
# ‚ïü‚îÄ87c3f5cd-79bf-4ad8-b7f8-3e98ec548a9f
# ‚ïü‚îÄ2313198e-3ac9-407b-b0d6-b79e02cefe35
# ‚ïü‚îÄb0291e05-776e-49ce-919f-4ad7de4070af
# ‚ïü‚îÄd4a9da7a-f455-426b-aecd-227c25e1d4e8
# ‚ïü‚îÄf098570d-799b-47e2-b692-476a4d95825b
# ‚ïü‚îÄcaf67b2f-cc2f-4d0d-b619-6e1969fabc1a
# ‚ïü‚îÄ6f14a72c-51d3-4759-bb8b-10db1dc260f0
# ‚ïü‚îÄ22fe8006-0e81-4e0a-a460-28610a55cd97
# ‚ïü‚îÄdb4371e4-7f86-4db3-b076-12f6cd220b89
# ‚ïü‚îÄ317995ed-bdf4-4f78-bd66-a39ffd1dc452
# ‚ïü‚îÄca5a4cef-df67-4a5e-8a86-75a9fe8c6f37
# ‚ïü‚îÄ24f7aae7-d37a-4db5-ace0-c910b178da88
# ‚ïü‚îÄ37f951ee-885c-4bbe-a05f-7c5e48ff4b6b
# ‚ïü‚îÄdc696281-7a5b-4568-a4c2-8dde90af43f0
# ‚ïü‚îÄeb92ff7c-0140-468c-8b32-f15d1cf15913
# ‚ïü‚îÄf0eaf96b-0bc0-4194-9a36-886cb1d66e00
# ‚ïü‚îÄ0099145a-5460-4549-9513-054bc1b04eea
# ‚ïü‚îÄ7968de5e-5ae8-4ab4-b089-c3d33475af2f
# ‚ïü‚îÄf92a6b6e-a556-45cb-a1ae-9f5fe791ffd2
# ‚ïü‚îÄec2a065f-0dc7-44d4-a18b-6c6a228b3ffc
# ‚ïü‚îÄ0e39a993-bb2f-4897-bfe2-5128ec62bef9
# ‚ïü‚îÄ6acb0a97-6469-499f-a5cf-6335d6aa909a
# ‚ïü‚îÄ595423df-728b-43b1-ade4-176785c54be3
# ‚ïü‚îÄfbffaab6-3154-49df-a226-d5810d0b7c38
# ‚ïü‚îÄ1f48143a-2152-4bb9-a765-a25e70c281a3
